// Code generated by sqlc. DO NOT EDIT.
// source: referencetype.sql

package db

import (
	"context"
	"database/sql"
	"github.com/google/uuid"
	"simplebank/model"
)

const createReferenceType = `-- name: CreateReferenceType :one
INSERT INTO Reference_Type(
  Code, Title, Description, Other_Info) 
VALUES (
  $1, $2, $3, $4
) 
RETURNING id, uuid, code, title, description, other_info
`

type ReferenceTypeRequest struct {
	Id          int64          `json:"id"`
	Code        sql.NullString `json:"code"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	OtherInfo   sql.NullString `json:"otherInfo"`
}

// func (m *PostgresDatastore) FollowGopher(owner string, friend string) error {
// 	return m.ExecuteSQL(
// 		"INSERT INTO friend_relation(owner_uuid, friend_uuid) VALUES($1, $2)", owner, friend)
// }

func (q *QueriesReference) CreateReferenceType(ctx context.Context, arg ReferenceTypeRequest) (model.ReferenceType, error) {
	row_ := q.db.QueryRowContext(ctx, createReferenceType,
		arg.Code,
		arg.Title,
		arg.Description,
		arg.OtherInfo,
	)
	var i model.ReferenceType
	err := row_.Scan(
		&i.Id,
		&i.Uuid,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.OtherInfo,
	)
	return i, err
}

const deleteReferenceType = `-- name: DeleteReferenceType :exec
DELETE FROM Reference_Type
WHERE id = $1
`

func (q *QueriesReference) DeleteReferenceType(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteReferenceType, id)
	return err
}

const getReferenceType = `-- name: GetReferenceType :one
SELECT 
  y.Id, y.UUId, y.Code, y.Title, y.Description, y.Other_Info
FROM Reference_Type y 
WHERE id = $1 LIMIT 1
`

func (q *QueriesReference) GetReferenceType(ctx context.Context, id int64) (model.ReferenceType, error) {
	row_ := q.db.QueryRowContext(ctx, getReferenceType, id)
	var i model.ReferenceType
	err := row_.Scan(
		&i.Id,
		&i.Uuid,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.OtherInfo,
	)
	return i, err
}

const getReferenceTypeInfo = `-- name: GetReferenceTypeInfo :one
SELECT 
  y.Id, y.UUId, y.Code, y.Title, y.Description, y.Other_Info,
  mr.Mod_Ctr, mr.Created, mr.Updated
FROM Reference_Type y INNER JOIN Main_Record mr on mr.UUId = y.UUId
WHERE id = $1 LIMIT 1
`

type ReferenceTypeInfo struct {
	Id          int64          `json:"id"`
	Uuid        uuid.UUID      `json:"uuid"`
	Code        sql.NullString `json:"code"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	OtherInfo   sql.NullString `json:"otherInfo"`
	ModCtr      int64          `json:"modCtr"`
	Created     sql.NullTime   `json:"created"`
	Updated     sql.NullTime   `json:"updated"`
}

func (q *QueriesReference) GetReferenceTypeInfo(ctx context.Context, id int64) (ReferenceTypeInfo, error) {
	row_ := q.db.QueryRowContext(ctx, getReferenceTypeInfo, id)
	var i ReferenceTypeInfo
	err := row_.Scan(
		&i.Id,
		&i.Uuid,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.OtherInfo,
		&i.ModCtr,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getReferenceTypeInfobyCode = `-- name: GetReferenceTypeInfobyCode :one
SELECT 
  y.Id, y.UUId, y.Code, y.Title, y.Description, y.Other_Info,
  mr.Mod_Ctr, mr.Created, mr.Updated
FROM Reference_Type y INNER JOIN Main_Record mr on mr.UUId = y.UUId
WHERE code = $1 LIMIT 1
`

func (q *QueriesReference) GetReferenceTypeInfobyCode(ctx context.Context, code sql.NullString) (ReferenceTypeInfo, error) {
	row_ := q.db.QueryRowContext(ctx, getReferenceTypeInfobyCode, code)
	var i ReferenceTypeInfo
	err := row_.Scan(
		&i.Id,
		&i.Uuid,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.OtherInfo,
		&i.ModCtr,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getReferenceTypeInfobyTitle = `-- name: GetReferenceTypeInfobyTitle :one
SELECT 
  y.Id, y.UUId, y.Code, y.Title, y.Description, y.Other_Info,
  mr.Mod_Ctr, mr.Created, mr.Updated
FROM Reference_Type y INNER JOIN Main_Record mr on mr.UUId = y.UUId
WHERE LOWER(y.Title) = LOWER($1) LIMIT 1
`

func (q *QueriesReference) GetReferenceTypeInfobyTitle(ctx context.Context, title string) (ReferenceTypeInfo, error) {
	row_ := q.db.QueryRowContext(ctx, getReferenceTypeInfobyTitle, title)
	var i ReferenceTypeInfo
	err := row_.Scan(
		&i.Id,
		&i.Uuid,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.OtherInfo,
		&i.ModCtr,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getReferenceTypeInfobyUuId = `-- name: GetReferenceTypeInfobyUuId :one
SELECT 
  y.Id, y.UUId, y.Code, y.Title, y.Description, y.Other_Info,
  mr.Mod_Ctr, mr.Created, mr.Updated
FROM Reference_Type y INNER JOIN Main_Record mr on mr.UUId = y.UUId
WHERE y.UUId = $1 LIMIT 1
`

func (q *QueriesReference) GetReferenceTypeInfobyUuId(ctx context.Context, uuid uuid.UUID) (ReferenceTypeInfo, error) {
	row_ := q.db.QueryRowContext(ctx, getReferenceTypeInfobyUuId, uuid)
	var i ReferenceTypeInfo
	err := row_.Scan(
		&i.Id,
		&i.Uuid,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.OtherInfo,
		&i.ModCtr,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const listReferenceType = `-- name: ListReferenceType :many
SELECT 
  y.Id, y.UUId, y.Code, y.Title, y.Description, y.Other_Info,
  mr.Mod_Ctr, mr.Created, mr.Updated
FROM Reference_Type y INNER JOIN Main_Record mr on mr.UUId = y.UUId
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListReferenceTypeParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *QueriesReference) ListReferenceType(ctx context.Context, arg ListReferenceTypeParams) ([]ReferenceTypeInfo, error) {
	rows, err := q.db.QueryContext(ctx, listReferenceType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReferenceTypeInfo{}
	for rows.Next() {
		var i ReferenceTypeInfo
		if err := rows.Scan(
			&i.Id,
			&i.Uuid,
			&i.Code,
			&i.Title,
			&i.Description,
			&i.OtherInfo,
			&i.ModCtr,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReferenceType = `-- name: UpdateReferenceType :one

UPDATE Reference_Type SET 
  Code         = $2,
  Title        = $3,
  Description  = $4,
  Other_Info   = $5
WHERE id = $1
RETURNING id, uuid, code, title, description, other_info
`

// -- name: GetReferenceTypeForUpdate :one
// SELECT * FROM Reference_Type y
// WHERE id = $1 LIMIT 1
// FOR NO KEY UPDATE;
func (q *QueriesReference) UpdateReferenceType(ctx context.Context, arg ReferenceTypeRequest) (model.ReferenceType, error) {
	row_ := q.db.QueryRowContext(ctx, updateReferenceType,
		arg.Id,
		arg.Code,
		arg.Title,
		arg.Description,
		arg.OtherInfo,
	)
	var i model.ReferenceType
	err := row_.Scan(
		&i.Id,
		&i.Uuid,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.OtherInfo,
	)
	return i, err
}
